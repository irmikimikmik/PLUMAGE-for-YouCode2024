import getIsEMEA from "./getIsEMEA";
import isAddressInFront from "./isAddressInFront";

const googleTypeMap = {
  locality: "city",
  sublocality: "city",
  postal_town: "city",
  administrative_area_level_1: "province",
  administrative_area_level_2: "province-emea",
  postal_code: "postalCode",
  country: "country",
};

const adaptProvinceForEmea = (address, requireEmeaProvince) => {
  const shouldUpdateProvince = getIsEMEA(address.country) && address["province-emea"] && requireEmeaProvince;
  const { "province-emea": provinceEmea, ...otherAddressParam } = address;
  return {
    ...otherAddressParam,
    province: shouldUpdateProvince ? provinceEmea : address?.province,
  };
};

const adaptGooglePlacesToForm = (addressComponents, requireEmeaProvince) => {
  const adaptedAddress = {};
  let street, route, premise;
  let displayAddressInFront = false;
  if (Array.isArray(addressComponents) && addressComponents?.length) {
    addressComponents.forEach(({ short_name, long_name, types }) => {
      for (const type of types) {
        if (type === "street_number") {
          street = short_name;
        } else if (type === "route") {
          route = short_name;
        } else if (type === "premise") {
          premise = short_name;
        } else if (type === "administrative_area_level_1" || type === "country") {
          adaptedAddress[googleTypeMap[type]] = short_name;
          displayAddressInFront = isAddressInFront(short_name);
        } else if (googleTypeMap[type]) {
          adaptedAddress[googleTypeMap[type]] = long_name;
        }
      }
    });

    if (displayAddressInFront) {
      adaptedAddress.address1 = [street, route, premise].filter(attr => Boolean(attr)).join(" ");
    } else {
      adaptedAddress.address1 = [premise, route, street].filter(attr => Boolean(attr)).join(" ");
    }
  }
  return adaptProvinceForEmea(adaptedAddress, requireEmeaProvince);
};

export default adaptGooglePlacesToForm;
