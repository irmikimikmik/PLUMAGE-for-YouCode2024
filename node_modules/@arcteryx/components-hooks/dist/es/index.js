import { useEffect, useState, useMemo, useRef } from 'react';

/**
 * useIntersectionObserver
 * @param {ref} target ref of the element
 * @param {object} src
 * @param {function} onIntersect callback
 * @param {number} threshold
 * @param {string} rootMargin how much space from the screen to when the window meets
 * @param {boolean} enabled enables or disables the hook
 * @param {array} deps list of products
 * @param {number} delay to handle timing issues from smooth scrolling when product changes
 */

const useIntersectionObserver = _ref => {
  let {
    target,
    src = null,
    onIntersect,
    threshold = 0,
    rootMargin = "0px",
    enabled = true,
    deps = null,
    delay = 0
  } = _ref;
  useEffect(() => {
    const {
      current
    } = target;
    let observer;
    if (enabled && current && typeof IntersectionObserver !== "undefined") {
      setTimeout(() => {
        observer = new IntersectionObserver(onIntersect, {
          rootMargin,
          threshold,
          root: src ? src.current : null
        });
        observer.observe(current);
      }, delay);
    }
    return () => {
      if (observer) {
        observer.unobserve(current);
      }
    };
  }, deps);
};

const useSSR = () => {
  const isDOMavailable = !!(typeof window !== "undefined" && window.document && window.document.createElement);
  const [inBrowser, setInBrowser] = useState(isDOMavailable);
  useEffect(() => {
    setInBrowser(isDOMavailable);
    return () => {
      setInBrowser(false);
    };
  }, []);
  return useMemo(() => ({
    isBrowser: inBrowser,
    isServer: !inBrowser,
    canUseWorkers: typeof Worker !== "undefined",
    canUseEventListeners: inBrowser && !!window.addEventListener,
    canUseViewport: inBrowser && !!window.screen
  }), [inBrowser]);
};

/** Only changes state to isOnScreen once then disables the observer */
function useIsOnScreen() {
  let {
    rootMargin = "500px"
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
    rootMargin: "500px"
  };
  const ref = useRef(null);
  const [isOnScreen, setIsOnScreen] = useState(false);
  useIntersectionObserver({
    target: ref,
    rootMargin,
    enabled: !isOnScreen,
    deps: [isOnScreen],
    onIntersect: _ref => {
      let [{
        isIntersecting
      }] = _ref;
      setIsOnScreen(isIntersecting);
    }
  });
  return {
    ref,
    isOnScreen
  };
}

export { useIntersectionObserver, useIsOnScreen, useSSR };
//# sourceMappingURL=index.js.map
